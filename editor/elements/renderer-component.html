<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="renderer-component">

	<style>

    .panel {
		margin-top: 10px;
		color: black;
    }

	</style>

	<template>

        <div class="panel panel-primary"  hidden$="{{hideRenderer}}">
            <div class="panel-heading" on-click="hideComponent">
				<div class="row">
					<div class="col-md-6">
						<h3 class="panel-title">{{actor.renderer._editorName}}</h3>
					</div>
					<!-- utility buttons -->
				</div>
            </div>
            <div class="panel-body" hidden$="{{hideContent}}">
				<div class="container-fluid">
					<!-- rect renderer -->
	                <div hidden$="{{typeofRenderer('RectRenderer', actor.renderer)}}">

						<div class="row">
							<div class="col-md-6">
								<form class="form-horizontal">
									<div class="form-group form-group-sm">
										<label>size x</label>
				                        <input class="form-control" type="number" step="1" on-change="valuesChange" value="{{actor.renderer.size.x::input}}">
									</div>
								</form>
							</div>
							<div class="col-md-6">
								<form class="form-horizontal">
									<div class="form-group form-group-sm">
										<label>size y</label>
				                        <input class="form-control" type="number" step="1" on-change="valuesChange" value="{{actor.renderer.size.y::input}}">
				                    </div>
								</form>
							</div>
						</div>

						<div class="row">
							<div class="col-md-12">
								<label>layer</label>
								<input class="form-control" type="number" step="1" min="0" on-change="valuesChange" value="{{actor.renderer.layer::input}}">
							</div>
						</div>

						<div class="row">
							<div class="col-md-12">
								<label>color</label>
								<input class="form-control" type="text" on-change="valuesChange" value="{{actor.renderer.color::input}}">
							</div>
						</div>
					</div>

					<!-- sprite renderer -->
					<div hidden$="{{typeofRenderer('SpriteRenderer', actor.renderer)}}">

						<div class="row">
							<div class="col-md-12">
								<label>layer</label>
								<input class="form-control" type="number" step="1" min="0" on-change="valuesChange" value="{{actor.renderer.layer::input}}"></br>
							</div>
						</div>

						<div class="row">
							<div class="col-md-12">
								<label>sprite</label>
								<select class="form-control" on-change="spriteChange">
									<template is="dom-repeat" items="{{ sprites }}" as="sprite">
										<option value="{{sprite.name}}" selected$="{{selected(sprite.name, actor.renderer.sprite)}}">
											{{sprite.name}}
										</option>
									</template>
								</select>
							</div>
						</div>

					</div>

					<!-- animation renderer -->
					<div hidden$="{{typeofRenderer('AnimationRenderer', actor.renderer)}}">

						<div class="row">
							<div class="col-md-12">
								<label>play</label>
								<input id="play" class="checkbox" type="checkbox" on-change="valuesChange">
							</div>
						</div>

						<div class="row">
							<div class="col-md-12">
								<label>layer</label>
			                    <input class="form-control" type="number" step="1" min="0" on-change="valuesChange" value="{{actor.renderer.layer::input}}">
							</div>
						</div>

						<div class="row">
							<div class="col-md-12">
								<label>frames</label>
								<input class="form-control" type="number" step="1" min="1" on-change="valuesChange" value="{{actor.renderer.frames::input}}">
							</div>
						</div>

						<div class="row">
							<div class="col-md-12">
								<label>updatesPerFrame</label>
								<input class="form-control" type="number" step="1" min="0" on-change="valuesChange" value="{{actor.renderer.updatesPerFrame::input}}">
							</div>
						</div>


						<div class="row">
							<div class="col-md-12">
								<label>sprite</label>
								<select class="form-control" on-change="spriteChange">
									<template is="dom-repeat" items="{{ sprites }}" as="sprite">
										<option value="{{sprite.name}}" selected$="{{selected(sprite.name, actor.renderer.sprite)}}">
											{{sprite.name}}
										</option>
									</template>
								</select>
							</div>
						</div>

					</div>
	            </div>
			</div>
        </div>

	</template>

</dom-module>

<script>

	Polymer({
		is: 'renderer-component',

		properties: {

			actor: {
				type: Object,
				value: null,
				notify: true,
				observer: 'refreshActor'
			},

			sprites: {
				type: Array,
				value: [],
				observer: 'spriteUpdate'
			},

			hideContent: {
				type: Boolean,
				value: true
			},

			hideRenderer: {
				type: Boolean,
				value: true
			}
		},

		valuesChange: function() {

			//apply object changes to prefab
			if(this.actor) {

				//layer
				this.actor.prefab.renderer.args.layer = this.actor.renderer.layer;

				switch(this.actor.renderer.type) {
					case 'sprite':

						//sprite
						this.actor.prefab.renderer.args.sprite = this.actor.renderer.sprite;

					break;
					case 'animation':

						//sprite
						this.actor.prefab.renderer.args.sprite = this.actor.renderer.sprite;

						//frames
						this.actor.prefab.renderer.args.frames = this.actor.renderer.frames;

						//ups
						this.actor.prefab.renderer.args.updatesPerFrame = this.actor.renderer.updatesPerFrame;

						//play
						this.actor.prefab.renderer.args.play = this.actor.renderer.play = this.$.play.checked;

					break;
					case 'rect':

						//color
						this.actor.prefab.renderer.args.color = this.actor.renderer.color;

						//size
						this.actor.prefab.renderer.args.size.args.x = this.actor.renderer.size.x;
						this.actor.prefab.renderer.args.size.args.y = this.actor.renderer.size.y;

					break;
				}
			}
		},

		ready: function(){
			this.isRendererPresent();
		},

		spriteUpdate: function() {
			if(this.actor.renderer && (this.actor.renderer.type == 'sprite' || this.actor.renderer.type == 'animation') && !this.actor.renderer.sprite && this.sprites.length > 0) {
				this.actor.renderer.sprite = this.actor.prefab.renderer.args.sprite = this.sprites[0].name;
			}

		},

		typeofRenderer: function(type, current) {

			if(Amble.Graphics[type] && (current instanceof Amble.Graphics[type])) {
				return false;
			} else {
				return true;
			}
		},

		isRendererPresent: function(){

			if(this.actor.renderer && !(this.actor.renderer instanceof Amble.Graphics.EngineRenderer)) {
				this.hideContent = false;
				this.hideRenderer = false;

				this.spriteUpdate();

			} else {
				this.hideContent = true;
				this.hideRenderer = true;
			}
		},

		refreshActor: function() {

			if(this.actor.sceneID) {

				var sceneID = this.actor.sceneID;
				this.actor = Amble.app.scene.getActorByID(sceneID);

				this.sprites = [];
				for(var i in Amble.app.imgList) {
					this.push('sprites', Amble.app.imgList[i])
				}

				this.spriteUpdate();

				this.valuesChange();
				this.isRendererPresent();
			}
		},

		selected: function(item, type){
			return type == item;
		},

		spriteChange: function(e){

			if(this.actor instanceof Amble.Actor) {
				this.actor.renderer.sprite = e.target.value;
				this.valuesChange();
			}
		},

		hideComponent: function(){

			if(this.actor.renderer) {
				this.hideContent = !this.hideContent;
			}
		}

	});

</script>
