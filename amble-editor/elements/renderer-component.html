<link rel="import" href="../bower_components/polymer/polymer.html">

<dom-module id="renderer-component">

	<style>

    .title {
		/*color: red;*/
    }

    .content {

    }

	</style>

	<template>

        <div class="tranform"  hidden$="{{hideRenderer}}">
            <div class="title" on-click="hideComponent">
                Renderer
            </div>
            <div class="content" hidden$="{{hideContent}}">

				<!-- rect renderer -->
                <div class="row" hidden$="{{typeofRenderer('RectRenderer', actor.renderer)}}">

					<div class="row">
	                    <div class="col left">
	                        <label for="size-x">size x</label>
	                        <input id="size-x" type="number" step="1" on-change="valuesChange" value="{{actor.renderer.size.x::input}}">
	                    </div>
	                    <div class="col right">
	                        <label for="size-y">size y</label>
	                        <input id="size-y" type="number" step="1" on-change="valuesChange" value="{{actor.renderer.size.y::input}}">
	                    </div>
	                </div></br>

					<label for="layer">layer</label>
                    <input id="layer" type="number" step="1" min="0" on-change="valuesChange" value="{{actor.renderer.layer::input}}"></br>

					<label for="color">color</label>
                    <input id="color" type="text" on-change="valuesChange" value="{{actor.renderer.color::input}}"></br>

				</div>

				<!-- sprite renderer -->
				<div class="row" hidden$="{{typeofRenderer('SpriteRenderer', actor.renderer)}}">

					<label for="layer">layer</label>
                    <input id="layer" type="number" step="1" min="0" on-change="valuesChange" value="{{actor.renderer.layer::input}}"></br>

					<label for="sprite">sprite</label>
					<select id="sprite" on-change="spriteChange">
						<template id="spriteList" is="dom-repeat" items="{{ sprites }}" as="sprite">
							<option value="{{sprite.path}}" selected$="{{selected(sprite.path, actor.renderer.sprite)}}">
								{{sprite.path}}
							</option>
						</template>
					</select></br>

				</div>

				<!-- animation renderer -->
				<div class="row" hidden$="{{typeofRenderer('AnimationRenderer', actor.renderer)}}">

					<label for="play">play</label>
					<input id="play" type="checkbox" on-change="valuesChange"></br>

					<label for="layer">layer</label>
                    <input id="layer" type="number" step="1" min="0" on-change="valuesChange" value="{{actor.renderer.layer::input}}"></br>

					<label for="frames">frames</label>
					<input id="frames" type="number" step="1" min="1" on-change="valuesChange" value="{{actor.renderer.frames::input}}"></br>

					<label for="updatesPerFrame">updatesPerFrame</label>
					<input id="updatesPerFrame" type="number" step="1" min="0" on-change="valuesChange" value="{{actor.renderer.updatesPerFrame::input}}"></br>

					<label for="sprite">sprite</label>
					<select id="sprite" on-change="spriteChange">
						<template id="spriteList" is="dom-repeat" items="{{ sprites }}" as="sprite">
							<option value="{{sprite.path}}" selected$="{{selected(sprite.path, actor.renderer.sprite)}}">
								{{sprite.path}}
							</option>
						</template>
					</select></br>

				</div>

				<!-- anchor? -->
            </div>

			<div class="divider"></div>

        </div>


	</template>

</dom-module>

<script>

	Polymer({
		is: 'renderer-component',

		properties: {
			actor: {
				type: Object,
				value: null,
				notify: true,
				observer: 'refreshActor'
			},
			sprites: [],
			hideContent: {
				type: Boolean,
				value: true
			},
			hideRenderer: {
				type: Boolean,
				value: true
			}
		},

		valuesChange: function() {
			//apply object changes to prefab
			if(this.actor) {

				//layer
				this.actor.prefab.renderer.args.layer = this.actor.renderer.layer;

				switch(this.actor.renderer.type) {
					case 'sprite':

						//sprite
						this.actor.prefab.renderer.args.sprite = this.actor.renderer.sprite;

					break;
					case 'animation':

						//sprite
						this.actor.prefab.renderer.args.sprite = this.actor.renderer.sprite;

						//frames
						this.actor.prefab.renderer.args.sprite = this.actor.renderer.sprite;

						//ups
						this.actor.prefab.renderer.args.updatesPerFrame = this.actor.renderer.updatesPerFrame;

						//play
						this.actor.prefab.renderer.args.play = this.actor.renderer.play = this.$.play.checked;

					break;
					case 'rect':

						//color
						this.actor.prefab.renderer.args.color = this.actor.renderer.color;

						//size
						this.actor.prefab.renderer.args.size.args.x = this.actor.renderer.size.x;
						this.actor.prefab.renderer.args.size.args.y = this.actor.renderer.size.y;

					break;
				}
			}
		},

		ready: function(){
			this.isRendererPresent();
		},

		typeofRenderer: function(type, current) {
			if(Amble.Graphics[type] && (current instanceof Amble.Graphics[type])) {
				return false;
			} else {
				return true;
			}
		},

		isRendererPresent: function(){
			if(this.actor.renderer && !(this.actor.renderer instanceof Amble.Graphics.EngineRenderer)) {
				this.hideContent = false;
				this.hideRenderer = false;
			} else {
				this.hideContent = true;
				this.hideRenderer = true;
			}
		},

		refreshActor: function() {

			this.sprites = Amble.app.loader.cache.filter(c => c.type === 'image');

			if(this.actor.sceneID) {
				var sceneID = this.actor.sceneID;
				this.actor = Amble.app.scene.getActorByID(sceneID);

				this.valuesChange();
				this.isRendererPresent();
			}
		},

		selected: function(item, type){
			return type == item;
		},

		spriteChange: function(e){
			if(this.actor instanceof Amble.Actor) {
				this.actor.renderer.sprite = e.target.value;
				this.valuesChange();
			}
		},

		hideComponent: function(){
			if(this.actor.renderer) {
				this.hideContent = !this.hideContent;
			}
			// this.isRendererPresent();
		}

	});

</script>
